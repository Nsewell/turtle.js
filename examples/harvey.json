[{"text":"<CITE>Content from <A HREF=\"http://www.cs.berkeley.edu/~bh/\">Brian Harvey</A>, University of California, Berkeley</CITE>\n<P>\nLogo is best known as the language that introduced the <EM>turtle</EM>\nas a tool for computer graphics.  In fact, to many people, Logo and\nturtle graphics are synonymous.  Some computer companies have\ngotten away with\nselling products called &quot;Logo&quot; that provided nothing <EM>but</EM>\nturtle graphics, but if you bought a &quot;Logo&quot; that provided only the\nlist processing primitives we've used so far, you'd probably feel\ncheated.\n\n<P>Historically, this idea that Logo is mainly turtle graphics is a\nmistake.  As I mentioned at the beginning of Chapter 1, Logo's name\ncomes from the Greek word for <EM>word,</EM> because Logo was first\ndesigned as a language in which to manipulate language: words and\nsentences.  Still, turtle graphics has turned out to be a very\npowerful addition to Logo.  One reason is that any form of computer\ngraphics is an attention-grabber.  But other programming languages had\nallowed graphics programming before Logo.  In this chapter we'll look\nat some of the reasons why <EM>turtle</EM> graphics, specifically, was\nsuch a major advance in programming technology.\n\n<P>This chapter can't be long enough to treat the possibilities of\ncomputer graphics fully.  My goal is merely to show you that the same\nideas we've been using with words and lists are also\nfruitful in a very different problem domain.  Ideas like locality,\nmodularity, and recursion appear here, too, although sometimes in\ndifferent guises.\n\n<P><H2>A Review, or a Brief Introduction</H2>\n\n<P>I've been assuming that you've already been introduced to Logo turtle\ngraphics, either in a school or by reading Logo\ntutorial books.  If not, perhaps\nyou should read one of those books now.  But just in case, here is a\nvery brief overview of the primitive procedures for turtle graphics.\nAlthough some versions of Logo allow more than one turtle, or allow\n<EM>dynamic</EM> turtles with programmable shapes and speeds, for now\nI'll only consider the traditional, single, static turtle.\n\n<P>Type the command <CODE>cs</CODE> (short for <CODE>clearscreen</CODE>), with no\ninputs.  The effect of this command is to initiate Logo's graphics\ncapability.  A turtle will appear in the center of a graphics window.\n(Depending on which version of Logo you have, the turtle may look like an\nactual animal with a head and four legs or--as in Berkeley Logo--it may be\nrepresented as a triangle.) The turtle will be facing toward the top of the\nscreen.  Any previous graphic drawing will be erased from the screen and\nfrom the computer's memory.\n\n<P>The crucial thing about the turtle, which distinguishes it from other\nmetaphors for computer graphics, is that the turtle is pointing in a\nparticular direction and can only move in that direction.  (It can\nmove forward or back, like a car with reverse gear, but not sideways.)\nIn order to draw in any other direction, the turtle must <EM>first</EM>\nturn so that it is facing in the new direction.  (In this respect it\nis unlike a car, which must turn and move at the same time.)\n\n<P>The primary means for moving the turtle is the <CODE>forward</CODE> command,\nabbreviated <CODE>fd</CODE>.  <CODE>Forward</CODE> takes one input, which must be a\nnumber.  The effect of <CODE>forward</CODE> is to move the turtle in the\ndirection it's facing, through a distance specified by the input.  The\nunit of distance is the &quot;turtle step,&quot; a small distance that depends\non the resolution of your computer's screen.  (Generally, one turtle\nstep is the smallest line your computer can draw.  This is\nslightly oversimplified, though, because that smallest distance may be\ndifferent in different directions.  But the size of a turtle step does\n<EM>not</EM> depend on the direction; it's always the same distance for\nany given computer.)  Try typing the command\n\n<P>\n","code":"\nforward 80                     \n"},{"text":"<TD valign=\"center\"><IMG SRC=\"fd80.gif\" ALT=\"turtle figure\">\n\n<P>Since the turtle was facing toward the top of the screen,\nthat's the way it moved.  The turtle should now be higher on the\nscreen, and there should be a line behind it indicating the path\nthat it followed.\n\n<P>The first turtles were actual robots that rolled along the floor.\nThey got the name &quot;turtle&quot; because of the\nhard shells surrounding their delicate electronic innards.  A robot\nturtle has a pen in its belly, which it can push down to the floor, or\npull up inside itself.  When the pen is down, the turtle draws a trace\nof its motion along the floor.\n\n<P>\n<P>When talking about the screen turtle, it's customary to think of the\nscreen as a kind of map, representing a horizontal floor.  Therefore,\ninstead of referring to the screen directions as &quot;up,&quot; &quot;down,&quot;\n&quot;left,&quot; and &quot;right,&quot; we talk about the compass headings North,\nSouth, West, and East.  Your turtle is now facing North.  Besides\nfitting better with the turtle metaphor, this terminology avoids a\npossible confusion: the word &quot;left&quot; could mean either the <EM>\nturtle's</EM> left or the <EM>screen's</EM> left.  (They're the same\ndirection right now, but they won't be the same after we turn the\nturtle.)  To avoid this problem, we use &quot;West&quot; for the left edge of\nthe screen, and reserve the word &quot;left&quot; for the direction to the\nleft of whichever way the turtle is facing.\n\n<P>Logo provides primitive commands to raise and lower the turtle's pen.\nThe command <CODE>penup</CODE> (abbreviated <CODE>pu</CODE>) takes no inputs; its\neffect is to raise the pen.  In other words, after you use this\ncommand, any further turtle motion won't draw lines.  Try it now:\n\n<P>\n","code":"penup                          \nforward 30\n"},{"text":"<TD valign=\"center\"><IMG SRC=\"pufd30.gif\" ALT=\"turtle figure\">\n\n<P>Similarly, the command <CODE>pendown</CODE> (<CODE>pd</CODE>) takes no\ninputs, and lowers the pen.  Here's a procedure you can try:\n\n<P>\n","code":"to dash :count\nrepeat :count [penup forward 4 pendown forward 4]      \nend"},{"text":"\n<TD valign=\"center\"><IMG SRC=\"dash14.gif\" ALT=\"turtle figure\">\n\n<P>The command <CODE>back</CODE> (or <CODE>bk</CODE>) takes one input, which must be a\nnumber.  The effect of <CODE>back</CODE> is to move the turtle backward by\nthe distance used as its input.  (What do you think <CODE>fd</CODE> and <CODE>\nbk</CODE> will do if you give them noninteger inputs?  Zero inputs?\nNegative inputs?  Try these possibilities.  Then look up the commands\nin the reference manual for your version of Logo and see if the\nmanual describes the commands fully.)\n\n<P>To turn the turtle, two other commands are provided.  <CODE>Left</CODE>\n(abbreviated <CODE>lt</CODE>) takes one input, which must be a number.  Its\neffect is to turn the turtle toward the <EM>turtle's</EM> own left.\nThe angle through which the turtle turns is the input; angles are\nmeasured in degrees, so\n<CODE>left 360</CODE>\nwill turn the turtle all the way around.  (In other words, that\ninstruction has no real effect!)  Another way of saying that the turtle\nturns toward its own left is that it turns <EM>counterclockwise.</EM>\nThe command <CODE>right</CODE> (or <CODE>rt</CODE>) is just like <CODE>left</CODE>, except\nthat it turns the turtle clockwise, toward its own right.\n\n<P>&raquo;Clear the screen and try this, the classic beginning point of Logo\nturtle graphics:\n\n<P>","code":"repeat 4 [forward 100 right 90]\n"},{"text":"\n\n<P>This instruction tells Logo to draw four lines, each 100\nturtle steps long, and to turn 90 degrees between lines.  In other\nwords, it draws a square.\n\n<P>There are many more turtle procedures provided in Logo, but these are\nthe fundamental ones; with them you can go quite far in generating\ninteresting computer graphics.  If you haven't had much experience\nwith turtle graphics before, you might enjoy spending some time\nexploring the possibilities.  There are many introductory Logo\nturtle graphics books to help you.  Because that part of Logo\nprogramming is so thoroughly covered elsewhere, I'm not going to\nsuggest graphics projects here.  Instead I want to go on to consider\nsome of the deeper issues in computer programming that are\nilluminated by the turtle metaphor.\n\n<P><H2>Local vs. Global Descriptions</H2>\n\n<P>Earlier we considered the difference between <EM>local</EM> variables,\nwhich are available only within a particular procedure, and <EM>\nglobal</EM> variables, which are used throughout an entire project.\nI've tried to convince you that the use of local variables is a much\nmore powerful programming style than one that relies on global\nvariables for everything.  For one thing, local variables are\nessential to make recursion possible; in order for a single procedure\nto solve a large problem and a smaller subproblem simultaneously, each\ninvocation of the procedure must have its own, independent variables.\nBut even when recursion is not an issue, a complex program is much\neasier to read and understand if each procedure can be understood\nwithout thinking about the context in which it's used.\n\n<P>The turtle approach to computer graphics embodies the same principle of\nlocality, in a different way.  The fact that the turtle motion\ncommands (<CODE>forward</CODE> and <CODE>back</CODE>) and the turtle turning commands (<CODE>\nleft</CODE> and <CODE>right</CODE>) are all <EM>turtle-relative</EM> means that a\ngraphics procedure need not think about the larger picture.\n\n<P>To understand what that means, you should compare the turtle metaphor\nwith the other metaphor that is commonly used in computer\ngraphics: <EM>Cartesian coordinates.</EM>  This metaphor\ncomes from analytic geometry,\ninvented by Rene Descartes\n(1596-1650).  The word &quot;Cartesian&quot; is derived from his\nname.  Descartes' goal was to use the techniques of algebra in solving\ngeometry problems by using <EM>numbers</EM> to describe <EM>points.</EM>\nIn a two-dimensional plane, like your computer screen, you need two\nnumbers to identify a point.  These numbers work like longitude and\nlatitude in geography: One tells how far the point is to the left\nor right and the other tells how high up it is.\n\n<P><CENTER><IMG SRC=\"cartesian.gif\" ALT=\"figure: cartesian\"></CENTER>\n\n<P>\nThis diagram shows a computer screen with a grid of horizontal and\nvertical lines drawn on it.  The point where the two heavy lines meet\nis called the <EM>origin;</EM> it is represented by the numbers\n<CODE>[0 0]</CODE>.  For other points the first number (the <EM>\nx-coordinate</EM>) is the horizontal distance from the origin to the\npoint, and the second number (the <EM>y-coordinate</EM>) is the\nvertical distance from the origin to the point.  A positive\nx-coordinate means that the point is to the right of the origin; a\nnegative x-coordinate means that the point is to the left of the\norigin.  Similarly, a positive y-coordinate means that the point is\nabove the origin; a negative y-coordinate puts it below the origin.\nLogo does allow you to refer to points by their Cartesian coordinates,\nusing a list of two numbers.  The origin is the point where the turtle\nstarts when you clear the screen.\n\n<P>The primary tool for Cartesian-style graphics in Logo is the command\n<CODE>setpos</CODE> (for <CODE>set</CODE> <CODE>pos</CODE>ition).  <CODE>Setpos</CODE>\nrequires one input, which must be a list of two numbers.  Its effect\nis to move the turtle to the point on the screen at those\ncoordinates.  If the pen is down, the turtle draws a line as it moves,\njust as it does for <CODE>forward</CODE> and <CODE>back</CODE>.  Here is how you\nmight draw a square using Cartesian graphics instead of turtle\ngraphics:\n\n<P>","code":"clearscreen\nsetpos [0 100]\nsetpos [100 100]\nsetpos [100 0]\nsetpos [0 0]\n"},{"text":"\n\n<P>Do you see why I said that the Cartesian metaphor is global, like the\nuse of global variables?  Each instruction in this square takes into\naccount the turtle's position within the screen as a whole.  The\n&quot;point of view&quot; from which we draw the picture is that of an\nobserver standing above the plane looking down on all of it.  This\nobserver sees not only the turtle but also the edges and center of\nthe screen as part of what is relevant to drawing each line.  By\ncontrast, the turtle geometry metaphor adopts the point of view of the\nturtle itself; each line is drawn without regard to where the turtle\nis in global terms.\n\n<P>Using the turtle metaphor, we can draw our square (or any other figure\nwe can program) anywhere on the screen at any orientation.  First\nI'll write a <CODE>square</CODE> command:\n\n<P>","code":"to square :size\nrepeat 4 [forward :size right 90]\nend\n"},{"text":"\n\n<P>Now here's an example of how <CODE>square</CODE> can be used in\ndifferent positions and orientations:\n\n<P>\n","code":"to face\npendown square 100\npenup forward 20\nright 90\nforward 25\npendown forward 50\npenup back 75\nleft 90\nforward 65\nright 90\nforward 20\npendown square 15\npenup forward 45\npendown square 15                     \npenup back 15\nright 90\nforward 20\nleft 45\npendown square 20\nend\n"},{"text":"<TD><IMG SRC=\"face.gif\" ALT=\"turtle figure\">\n\n<P>The head and the eyes are upright squares; the nose is a\nsquare at an angle (a diamond).  To write this program using Cartesian\ngraphics, you'd have to know the absolute coordinates of the corners\nof each of the squares.  To draw a square at an unusual angle, you'd\nneed trigonometry to calculate the coordinates.\n\n<P>\n\n<P>&raquo;Here is another demonstration of the same point.  Clear the screen and\ntype this instruction:\n\n<P>","code":"repeat 20 [pendown square 12 penup forward 20 right 18]\n"},{"text":"\n\n<P>You'll see squares drawn in several different orientations.\nThis would not be a one-line program if you tried to do it using the\nCartesian metaphor!\n\n<P>\n\n<P>\n<H2>The Turtle's State</H2>\n\n<P>From a turtle's-eye point of view, drawing an upright square is the\nsame as drawing a diamond.  It's only from the global point of view,\ntaking the borders of the screen into account, that there is a\ndifference.\n\n<P>From the global point of view how can we think about that\ndifference?  How do we describe what makes the same procedure\nsometimes draw one thing (an upright square) and sometimes another (a\ndiamond)?  The answer, in the most general terms, is that the result\nof the <CODE>square</CODE> command depends on the past <EM>history</EM> of the\nturtle--its twists and turns before it got to wherever it may be\nnow.  That is, the turtle has a sort of memory of past events.\n\n<P>But what matters is not actually the turtle's entire past history.\nAll that counts is the turtle's current <EM>position</EM> and its\ncurrent <EM>heading,</EM> no matter how it got there.  Those two things,\nthe position and the heading, are called the turtle's <EM>state.</EM>\nIt's a little like trying to solve a Rubik's Cube; you may have turned\npart of the cube 100 times already, but all that counts now is the\ncurrent pattern of colors, not how you got there.\n\n<P>I've mentioned the <CODE>setpos</CODE> command, which sets the turtle's\nposition.  There is also a command <CODE>setheading</CODE> (abbreviated\n<CODE>seth</CODE>) to set the\nheading.  <CODE>Setheading</CODE> takes one input, a number.  The effect is to turn\nthe turtle so that it faces toward the compass heading specified by\nthe number.  Zero represents North; the heading is measured in degrees\nclockwise from North.  (For example, East is 90; West is 270.) The\ncompass heading is different from the system of angle measurement used\nin analytic geometry, in which angles are measured counterclockwise\nfrom East instead of clockwise from North.\n\n<P>In addition to commands that set the turtle's state, Logo provides\noperations to find out the state.  pos<CODE>Pos</CODE> is an operation\nwith no inputs.  Its output is a list of two numbers, representing the\nturtle's current position.  heading<CODE>Heading</CODE> is also an\noperation with no inputs.  Its output is a number, representing the turtle's\ncurrent heading.\n\n<P>Remember that when you use these state commands and operations, you're\nthinking in the global (Cartesian) style, not the local (turtle)\nstyle.  Global state is sometimes important, just as global variables\nare sometimes useful.  If you want to draw a picture containing three\nwidgets, you might use <CODE>setpos</CODE> to get the turtle into position\nfor each widget.  But the <CODE>widget</CODE> procedure, which draws each\nwidget, probably shouldn't use <CODE>setpos</CODE>.  (You might also use\n<CODE>setpos</CODE> extensively in a situation in which the Cartesian\nmetaphor is generally more appropriate than the turtle metaphor, like\ngraphing a mathematical function.)  As in the case of global\nvariables, you'll be most likely to overuse global graphics style if\nyou're accustomed to BASIC computer graphics.  A good rule of\nthumb, if you're doing something turtleish and not graphing a function, is\nthat you shouldn't use <CODE>setpos</CODE> with the pen down.\n\n<P>&raquo;Do you see why?\n\n<P>\n<H2>Symmetry</H2>\n\n<P>Very young children often begin playing with Logo simply by moving the\nturtle around at random.  The resulting pictures usually don't look\nvery interesting.  You can recapture the days of your youth by\nalternating <CODE>forward</CODE> and <CODE>right</CODE> commands with arbitrary inputs.\nHere is a sample, which I've embodied in a procedure:\n\n<P>\n","code":"to squiggle\nforward 100\nright 135\nforward 40                        \nright 120\nforward 60\nright 15\nend\n"},{"text":"<TD valign=\"center\"><IMG SRC=\"squiggle.gif\" ALT=\"turtle figure\">\n\n\n<P>This isn't a very beautiful picture.  But\nsomething interesting happens when you keep squiggling repeatedly:\n\n<P>\n","code":"repeat 20 [squiggle]             \n"},{"text":"<TD valign=\"center\"><IMG SRC=\"squiggle4.gif\" ALT=\"turtle figure\">\n\n<P>Instead of filling up the screen with hash, the turtle draws\na symmetrical shape and repeats the same path over and over!  Let's\ntry another example:\n\n<P>\n","code":"to squaggle\nforward 50\nright 150\nforward 60                       \nright 100\nforward 30\nright 90\nend\n"},{"text":"<TD valign=\"center\"><IMG SRC=\"squaggle.gif\" ALT=\"turtle figure\">\n\n\n<P><CODE>Squiggle</CODE> turns into a sort of fancy square when you repeat it;\n<CODE>squaggle</CODE> turns into an 18-pointed pinwheel.  Does every possible\nsquiggle produce a repeating pattern this way?  Yes.  Sometimes you\nhave to <CODE>repeat</CODE> the procedure many times, but essentially any\ncombination of <CODE>forward</CODE> and <CODE>right</CODE> commands will eventually retrace\nits steps.  (There's one exception, which we'll talk about shortly.)\n\n<P>To see why repetition brings order out of chaos, we have to think\nabout a simpler Logo graphics procedure that is probably very\nfamiliar to you:\n\n<P>","code":"to poly :size :angle\nforward :size\nright :angle\npoly :size :angle\nend\n"},{"text":"\n\n<P>Since this is a recursive procedure without a stop rule,\nit'll keep running forever.  You'll have to stop it by pressing the\nBREAK key, or command-period, or whatever your particular computer\nrequires.  The procedure draws regular polygons; here are some\nexamples to try:\n\n<P>","code":"poly 100 90\npoly 80 60\npoly 100 144\n"},{"text":"\n\n<P>A little thought (or some experimentation) will show you that\nthe <CODE>size</CODE> input makes the\npicture larger or smaller but doesn't change its shape.  The shape is\nentirely controlled by the <CODE>angle</CODE> input.\n\n<P>&raquo;What angle would you pick to draw a triangle?  A pentagon?  How do you\nknow?\n\n<P>The trick is to think about the turtle's state.  When you finish\ndrawing a polygon, the turtle must return to its original position\n<EM>and its original heading</EM> in order to be ready to retrace the\nsame path.  To return to its original heading, the turtle must turn\nthrough a complete circle, 360 degrees.  To draw a square, for\nexample, the turtle must turn through 360 degrees in four turns, so\neach turn must be 360/4 or 90 degrees.  To draw a triangle, each turn\nmust be 360/3 or 120 degrees.\n\n<P>&raquo;Now explain why an <CODE>angle</CODE> input of 144 draws a star!\n\n<P>Okay, back to our squiggles.  Earlier, I said that the only thing we\nhave to remember from the turtle's past history is the change in its\nstate.  It doesn't matter how that change came about.  When you draw a\n<CODE>squiggle</CODE>, the turtle moves through a certain distance and turns\nthrough a certain angle.  The fact that it took a\nroundabout path doesn't matter.  As it happens, <CODE>squiggle</CODE> turns\nright through 135+120+15 degrees, for a total of 270.  This is\nequivalent to turning left by 90 degrees.  That's why repeating <CODE>\nsquiggle</CODE> draws something shaped like a square.\n\n<P><CENTER><IMG SRC=\"turtlestate.gif\" ALT=\"figure: turtlestate\"></CENTER>\n\n<P>&raquo;What about <CODE>squaggle</CODE>?  If repeating it draws a figure with\n18-fold symmetry, then its total turning should be 360/18 or 20 degrees.  Is\nit?\n\n<P>&raquo;Here's another bizarre shape.  See if you can predict what kind of\nsymmetry it will show <EM>before</EM> you actually repeat it on the\ncomputer.\n\n<P>\n","code":"to squoggle\nforward 50\nright 70\nforward 10                       \nright 160\nforward 35\nright 58\nend\n"},{"text":"<TD valign=\"center\"><IMG SRC=\"squoggle.gif\" ALT=\"turtle figure\">\n\n\n<P>Suppose you like the shape of <CODE>squiggle</CODE>, but you want to draw a\ncompleted picture that looks triangular (3-fold symmetry) instead of\nsquare (4-fold).  Can you do this?  Of course; you can simply change\nthe last instruction of the <CODE>squiggle</CODE> procedure so that the total\nturning is 120 degrees instead of 90.  (Go ahead, try it.  Be careful\nabout left and right.)\n\n<P>But it's rather an ugly process to have to edit <CODE>squiggle</CODE> in\norder to change not what a squiggle looks like but how the squiggles\nfit into a larger picture.  For one thing, it violates the idea of\nmodularity.  <CODE>Squiggle</CODE>'s job should just be drawing a squiggle,\nand there should be another procedure, something like <CODE>poly</CODE>,\nthat combines squiggles into a symmetrical pattern.  For another,\npeople shouldn't have to do arithmetic; computers should do the\narithmetic!\n\n<P>To clean up our act, I'm going to start by writing a procedure that\ncan draw an arbitrary squiggle but without changing the turtle's\nheading.  It's called <CODE>protect.heading</CODE> because it protects the\nheading against change by the squiggle procedure.\n\n<P>","code":"to protect.heading :squig\nlocal &quot;oldheading\nmake &quot;oldheading heading\nrun :squig\nsetheading :oldheading\nend\n"},{"text":"\n\n<P>This procedure demonstrates the use of <CODE>heading</CODE>\nand <CODE>setheading</CODE>.  We remember the turtle's initial heading\nin the local variable <CODE>oldheading</CODE>.  Then we carry out whatever squiggle\nprocedure you specify as the input to <CODE>protect.heading</CODE>.  (The\n<CODE>run</CODE> command takes a Logo instruction list as input and evaluates\nit.)  Here is how you can use it:\n\n<P>","code":"protect.heading [squiggle]\nprotect.heading [squaggle]\n"},{"text":"\n\n<P>Notice that what is drawn on the screen is the same as it\nwould be if you invoked <CODE>squiggle</CODE> or <CODE>squaggle</CODE> directly; the\ndifference is that the turtle's final heading is the same as its\ninitial heading.\n\n<P><CENTER><IMG SRC=\"protect.gif\" ALT=\"figure: protect\"></CENTER>\n\n<P>\n\n<P>Now we can use <CODE>protect.heading</CODE> to write the decorated-<CODE>poly</CODE>\nprocedure that will let us specify the kind of symmetry we want:\n\n<P>","code":"to spin :turns :command\nrepeat :turns [protect.heading :command right 360/:turns]\nend\n"},{"text":"\n\n<P>&raquo;Try out <CODE>spin</CODE> with instructions like these:\n\n<P>\n","code":"spin 3 [squiggle]\nspin 5 [squiggle]\nspin 4 [squaggle]                   \nspin 6 [squoggle]\nspin 6 [fd 40 squoggle]\nspin 5 [pu fd 50 pd squaggle]\n"},{"text":"<TD valign=\"center\"><IMG SRC=\"spin.gif\" ALT=\"turtle figure\">\n\n\n<P>Isn't that better?\n\n<P>I mentioned that there is an exception to the rule that every squiggle\nwill eventually retrace its steps if you repeat it.  Here it is:\n\n<P>\n","code":"to squirrel\nforward 40\nright 90\nforward 10\nright 90\nforward 15                          \nright 90\nforward 20\nright 90\nend\n"},{"text":"<TD valign=\"center\"><IMG SRC=\"squirrel.gif\" ALT=\"turtle figure\">\n\n\n<P>&raquo;Try repeating <CODE>squirrel</CODE> 20 times.  You'll find that\ninstead of turning around to its original position and heading, the\nturtle goes straight off into the distance.  Why?  (<CODE>Squiggle</CODE> had\nfour-fold symmetry because its total turning was 90 degrees.  What is\nthe total turning of <CODE>squirrel</CODE>?) Of course, if you use <CODE>\nsquirrel</CODE> in the second input to <CODE>spin</CODE>, it will perform like the\nothers, because <CODE>spin</CODE> controls the turtle's heading in that case.\n\n<P>I've been using random squiggles with silly names to make\nthe point that by paying attention to symmetry, Logo <EM>can</EM> make\na silk purse from a sow's ear.  But of course there is no reason not\nto apply <CODE>spin</CODE> to more carefully designed pieces.  Here's one I\nlike:\n\n<P>\n","code":"to fingers :size\npenup forward 10 pendown\nright 5\nrepeat 5 [forward :size right 170 forward :size left 170] \nleft 5                                                 \npenup back 10 pendown\nend\n\nspin 4 [fingers 50]\nspin 10 [fingers 30]\n"},{"text":"<TD valign=\"center\"><IMG SRC=\"fingers.gif\" ALT=\"turtle figure\">\n\n\n<P>\n<H2>Fractals</H2>\n\n<P>I'd like to write a procedure to draw this picture of a tree:\n\n<P><CENTER><IMG SRC=\"tree.gif\" ALT=\"figure: tree\"></CENTER>\n\n<P>The trick is to identify this as a recursive problem.  Do\nyou see the smaller-but-similar subproblems?  The tree consists of a\ntrunk with two smaller trees attached.\n\n<P><CENTER><IMG SRC=\"splittree.gif\" ALT=\"figure: splittree\"></CENTER>\n\n<P>So a first approximation to the solution might look like this:\n\n<P>","code":"to tree :size\nforward :size\nleft 20\ntree :size/2\nright 40\ntree :size/2\nend\n"},{"text":"\n\n<P>If you try running this procedure, you'll see that we still\nhave some work to do.  But let me remind you that an unfinished\nprocedure like this isn't a <EM>mistake;</EM> you shouldn't feel that\nyou have to have every detail worked out before you first touch the\nkeyboard.  The first obvious problem is that there is no stop rule, so\nthe procedure keeps trying to draw smaller and smaller subtrees.  What\nshould the limiting condition be?  In this case there is no obvious\nend, like the <CODE>butfirst</CODE> of a word becoming empty.\n\n<P>There are two approaches we could take to limiting the number of\nbranches of the tree.  One approach would be to choose explicitly how\ndeep we want to get in recursive invocations.  We could do this by\nadding another input, called <CODE>depth</CODE>, that will be the number of\nlevels of recursion to allow:\n\n<P>","code":"to tree :depth :size\nif :depth=0 [stop]\nforward :size\nleft 20\ntree (:depth-1) :size/2\nright 40\ntree (:depth-1) :size/2\nend\n"},{"text":"\n\n<P>The other approach would be to keep letting the branches get\nsmaller until they go below a reasonable minimum:\n\n<P>","code":"to tree :size\nif :size&lt;4 [stop]\nforward :size\nleft 20\ntree :size/2\nright 40\ntree :size/2\nend\n"},{"text":"\n\n<P>Either approach is reasonable.  I'll choose the second one\njust because it seems a little simpler.  The cost of that choice is\nsomewhat less control over the final picture; I'm not sure if it'll\nhave exactly the number of branches I originally planned.\n\n<P>The modified procedure does come to a halt now, but it still doesn't\ndraw the tree I had in mind.  The problem is that this version of <CODE>\ntree</CODE> is not <EM>state-invariant:</EM> it doesn't leave the turtle with\nthe same position and heading that it had originally.  That's\nimportant because when <CODE>tree</CODE> says\n\n<P>","code":"tree :size/2\nright 40\ntree :size/2\n"},{"text":"\n\n<P>the assumption is that at the end of the first smaller tree\nthe turtle will be back at the top of the main trunk, in position to\ndraw the second subtree.  We can fix the problem by making the turtle\nclimb back down the trunk (of each subtree):\n\n<P>","code":"to tree :size\nif :size&lt;4 [stop]\nforward :size\nleft 20\ntree :size/2\nright 40\ntree :size/2\nleft 20\nback :size\nend\n"},{"text":"\n\n<P>Voila!  If you try <CODE>tree 50</CODE> you'll see something like the\npicture I had in mind.\n\n<P>You're probably thinking that this &quot;tree&quot; doesn't look very tree-like.\nThere are several things wrong with it:  It's too symmetrical; it doesn't\nhave enough branches; the branches should grow partway up the trunk as well\nas at the top.  But all of these problems can be solved by adding a few more\nsteps to the procedure:\n\n<P>\n","code":"to tree :size\nif :size &lt; 5 [forward :size back :size stop]\nforward :size/3\nleft 30 tree :size*2/3 right 30\nforward :size/6\nright 25 tree :size/2 left 25           \nforward :size/3\nright 25 tree :size/2 left 25\nforward :size/6\nback :size\nend\n"},{"text":"<TD valign=\"center\"><IMG SRC=\"realtree.gif\" ALT=\"turtle figure\">\n\n\n<P>We can embellish the tree as much as we want.  The only\nrequirement is that the procedure be state-invariant:  The turtle's final\nposition and heading must be the same as its beginning position and heading.\n\n<P>\n\n<P>Because I chose to use a minimum length as the stopping condition, the\nshape of the tree depends on the size of its trunk.  That's slightly\nunusual in turtle graphics programs, which usually draw the same shape\nregardless of the size.\n\n<P>A recursively-defined shape (one that contains smaller versions of itself)\nis called a <EM>fractal.</EM> Until the 1970s, hardly anybody explored\nfractals except for kids learning Logo and a few recreational mathematicians.\nToday, however, fractals have become important becase movie producers are\nusing computer graphics as an alternative to expensive sets and models for\nfancy special effects.  It turns out that programs like <CODE>tree</CODE> are the\nsecret of drawing realistic clouds, mountains, and other natural\nbackgrounds with a computer.\n\n<P>&raquo;If you want another challenging fractal project, try writing a program\nto produce these fractal snowflakes:\n\n<P><CENTER><IMG SRC=\"flake.gif\" ALT=\"figure: flake\"></CENTER>\n\n<P><H2>Further Reading</H2>\n\n<P>If you're interested in an intellectually rigorous exploration of\nturtle geometry, continuing along the lines I've started here,\nread\n<A HREF=\"http://mitpress.mit.edu/catalog/item/default.asp?sid=21C60546-CCA2-45E0-AA55-8E6BAC3EB07F&ttype=2&tid=7287\"><EM>Turtle Geometry</EM></A>,\nAbelson and diSessa (MIT Press,\n1981).  I learned many of the things in this chapter from them.  It's\na hard book but worth the effort.\n\n<P>The standard reference book on fractals is <EM>The Fractal Geometry\nof Nature,</EM> by Benoit Mandelbrot (W. H. Freeman, 1982).\nDr. Mandelbrot gave fractals their name and was the first to see\nserious uses for them.\n\n<P><A HREF=\"../v1-toc2.html\">(back to Table of Contents)</A>\n<P><A HREF=\"../v1ch9/v1ch9.html\"><STRONG>BACK</STRONG></A>\nchapter thread <A HREF=\"../v1ch11/v1ch11.html\"><STRONG>NEXT</STRONG></A>\n\n<P>\n<ADDRESS>\n<A HREF=\"../index.html\">Brian Harvey</A>, \n<CODE>bh@cs.berkeley.edu</CODE>\n</ADDRESS>\n</BODY>\n</HTML>\n"}]
